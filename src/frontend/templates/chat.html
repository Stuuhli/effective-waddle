<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RAG Platform – Chat</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('frontend_static', path='chat.css') }}"
    />
  </head>
  <body data-admin="{{ 'true' if is_admin else 'false' }}">
    <div class="chat-layout chat-layout--sidebar-open" id="chat-layout">
      <aside class="sidebar" id="sidebar">
        <div class="sidebar__header">
          <h2>Conversations</h2>
        </div>
        <nav class="sidebar__section">
          <div class="sidebar__section-header">
            <h3>Recent</h3>
            <button class="sidebar__link sidebar__link--ghost" id="new-conversation" type="button">
              <span class="icon icon--plus"></span>
              New conversation
            </button>
          </div>
          <ul class="conversation-list" id="conversation-list">
            {% if conversations %}
              {% for convo in conversations %}
                <li class="conversation-list__item">
                  <button
                    class="conversation-list__button"
                    type="button"
                    data-id="{{ convo.id }}"
                    data-title="{{ convo.title or '' }}"
                  >
                    <span class="conversation-list__title">{{ convo.title or 'New session' }}</span>
                    <span class="conversation-list__meta">
                      {{ convo.updated_at.strftime("%Y-%m-%d %H:%M") if convo.updated_at else '' }}
                    </span>
                  </button>
                </li>
              {% endfor %}
            {% else %}
              <li class="conversation-list__empty">No conversations yet. Create your first one to begin.</li>
            {% endif %}
          </ul>
        </nav>
        <nav class="sidebar__section sidebar__section--admin" id="admin-links" aria-label="Admin tools">
          <h3>Admin tools</h3>
          <a class="sidebar__link" href="/frontend/ingestion">Ingestion Console</a>
          <a class="sidebar__link" href="/frontend/admin">User Management</a>
        </nav>
      </aside>

      <div class="main">
        <header class="main__header">
          <button class="sidebar-toggle" id="sidebar-open" type="button" aria-label="Toggle sidebar" aria-pressed="true">
            <span id="sidebar-toggle-icon" aria-hidden="true">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="24" height="24" fill="#eeeeef"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg>
            </span>
          </button>
          <div class="main__title">
            <h1>Chat Console</h1>
            <p>Ask KiRa about anything, manage conversations, or jump into admin tools.</p>
          </div>
          <div class="main__header-actions">
            <button class="icon-button fullscreen-toggle" id="fullscreen-toggle" type="button" aria-label="Enter fullscreen" aria-pressed="false">
              <span class="fullscreen-toggle__icon fullscreen-toggle__icon--enter" aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="20" height="20" fill="#eeeeef"><path d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"/></svg>
              </span>
              <span class="fullscreen-toggle__icon fullscreen-toggle__icon--exit" aria-hidden="true" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="20" height="20" fill="#eeeeef"><path d="M240-120v-120H120v-80h200v200h-80Zm400 0v-200h200v80H720v120h-80ZM120-640v-80h120v-120h80v200H120Zm520 0v-200h80v120h120v80H640Z"/></svg>
              </span>
            </button>
            <div class="status-pill status-pill--idle" id="stream-status" role="status" aria-live="polite">
              Idle
            </div>
          </div>
        </header>

        <section class="chat-window" id="chat-window" aria-live="polite">
          <div class="message message--system">
            <span class="message__author">System</span>
            <p class="message__content">
              Select an existing conversation or start a new one to begin streaming responses. Messages will appear here.
            </p>
          </div>
        </section>

        <form class="composer" id="chat-form" autocomplete="off">
          <label class="composer__label" for="chat-input">Ask the model</label>
          <textarea
            class="composer__input"
            id="chat-input"
            name="message"
            rows="3"
            placeholder="What would you like to ask KiRa?"
            required
          ></textarea>
          <div class="composer__actions">
            <button class="button button--ghost" type="button" id="stop-stream" disabled>
              <span class="icon icon--stop"></span>
              Stop streaming
            </button>
            <button class="button button--primary" type="submit" id="send-button">
              <span class="icon icon--send"></span>
              Send & Stream
            </button>
          </div>
        </form>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script>
      const layout = document.getElementById('chat-layout');
      const sidebar = document.getElementById('sidebar');
      const sidebarOpen = document.getElementById('sidebar-open');
      const sidebarClose = document.getElementById('sidebar-close');
      const adminLinks = document.getElementById('admin-links');
      const chatWindow = document.getElementById('chat-window');
      const chatForm = document.getElementById('chat-form');
      const chatInput = document.getElementById('chat-input');
      const streamStatus = document.getElementById('stream-status');
      const stopStreamButton = document.getElementById('stop-stream');
      const sendButton = document.getElementById('send-button');
      const conversationList = document.getElementById('conversation-list');
      const newConversationButton = document.getElementById('new-conversation');
      const fullscreenToggle = document.getElementById('fullscreen-toggle');
      const fullscreenEnterIcon = fullscreenToggle?.querySelector('.fullscreen-toggle__icon--enter');
      const fullscreenExitIcon = fullscreenToggle?.querySelector('.fullscreen-toggle__icon--exit');
      const sidebarToggle = document.getElementById('sidebar-open');
      const sidebarToggleIcon = document.getElementById('sidebar-toggle-icon');
      let sidebarWasHidden = layout.classList.contains('chat-layout--sidebar-hidden');

      if (window.marked && window.marked.setOptions) {
        window.marked.setOptions({
          mangle: false,
          headerIds: false,
          breaks: true,
        });
      }

      function renderMarkdown(target, raw = '') {
        if (!target) {
          return;
        }
        if (typeof raw !== 'string') {
          target.textContent = '';
          return;
        }
        if (window.marked && window.DOMPurify) {
          const html = window.DOMPurify.sanitize(window.marked.parse(raw), { USE_PROFILES: { html: true } });
          target.innerHTML = html;
        } else if (window.marked) {
          target.innerHTML = window.marked.parse(raw);
        } else {
          target.textContent = raw;
        }
      }

      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) {
          return parts.pop().split(';').shift();
        }
        return '';
      }

      const cookieValue = document.cookie.split('; ').find((row) => row.startsWith('rag_admin='));
      const adminFlag = cookieValue ? cookieValue.split('=')[1] === '1' : document.body.dataset.admin === 'true';
      if (!adminFlag && adminLinks) {
        adminLinks.hidden = true;
      }

      function openSidebar() {
        const isFullscreen = layout.classList.contains('chat-layout--fullscreen');
        if (!isFullscreen) {
          layout.classList.add('chat-layout--sidebar-open');
          layout.classList.remove('chat-layout--sidebar-hidden');
          updateFullscreenToggle(false);
          sidebarWasHidden = false;
          sidebarWasOpen = true;
          setSidebarToggleState(true);
          return;
        }
        layout.classList.add('chat-layout--sidebar-open');
        layout.classList.remove('chat-layout--sidebar-hidden');
        sidebarWasHidden = false;
        sidebarWasOpen = true;
        setSidebarToggleState(true);
      }

      function closeSidebar() {
        const isFullscreen = layout.classList.contains('chat-layout--fullscreen');
        layout.classList.add('chat-layout--sidebar-hidden');
        layout.classList.remove('chat-layout--sidebar-open');
        sidebarWasHidden = true;
        sidebarWasOpen = false;
        setSidebarToggleState(false);
        if (!isFullscreen) {
          return;
        }
      }

      sidebarOpen?.addEventListener('click', () => {
        const isHidden = layout.classList.contains('chat-layout--sidebar-hidden');
        const isFullscreen = layout.classList.contains('chat-layout--fullscreen');
        if (isFullscreen) {
          if (isHidden) {
            openSidebar();
          } else {
            closeSidebar();
          }
          updateFullscreenToggle(true);
          return;
        }
        if (isHidden) {
          openSidebar();
        } else {
          closeSidebar();
        }
      });

      sidebarClose?.addEventListener('click', closeSidebar);

      fullscreenToggle?.addEventListener('click', () => {
        const willEnable = !layout.classList.contains('chat-layout--fullscreen');
        if (willEnable) {
          sidebarWasHidden = layout.classList.contains('chat-layout--sidebar-hidden');
          sidebarWasOpen = layout.classList.contains('chat-layout--sidebar-open');
          document.body.classList.add('chat-fullscreen');
          layout.classList.add('chat-layout--fullscreen');
          layout.classList.add('chat-layout--sidebar-hidden');
          layout.classList.remove('chat-layout--sidebar-open');
          setSidebarToggleState(false);
        } else {
          document.body.classList.remove('chat-fullscreen');
          layout.classList.remove('chat-layout--fullscreen');
          if (!sidebarWasHidden) {
            layout.classList.remove('chat-layout--sidebar-hidden');
          }
          if (sidebarWasOpen && !sidebarWasHidden) {
            layout.classList.add('chat-layout--sidebar-open');
            setSidebarToggleState(true);
          } else {
            setSidebarToggleState(false);
          }
        }
        updateFullscreenToggle(willEnable);
        sidebarWasHidden = layout.classList.contains('chat-layout--sidebar-hidden');
        sidebarWasOpen = layout.classList.contains('chat-layout--sidebar-open');
      });

      updateFullscreenToggle(document.body.classList.contains('chat-fullscreen'));
      setSidebarToggleState(
        !layout.classList.contains('chat-layout--sidebar-hidden') &&
          !layout.classList.contains('chat-layout--fullscreen'),
      );

      let activeConversationId = null;
      let abortController = null;
      let lastAssistantMessage = null;
      let streamingState = 'idle';
      let sidebarWasOpen = layout.classList.contains('chat-layout--sidebar-open');
      sidebarWasHidden = layout.classList.contains('chat-layout--sidebar-hidden');

      const stageMessages = {
        idle: 'Idle',
        streaming: 'Streaming…',
        retrieving: 'Retrieving relevant information…',
        retrieved: 'Context prepared.',
        generating: 'Generating response…',
        citations: 'Adding citations…',
        complete: 'Response ready.',
        error: 'Streaming error',
      };

      function updateFullscreenToggle(enabled) {
        if (!fullscreenToggle) {
          return;
        }
        fullscreenToggle.setAttribute('aria-pressed', String(enabled));
        fullscreenToggle.setAttribute('aria-label', enabled ? 'Exit fullscreen' : 'Enter fullscreen');
        if (fullscreenEnterIcon && fullscreenExitIcon) {
          fullscreenEnterIcon.hidden = enabled;
          fullscreenExitIcon.hidden = !enabled;
        }
      }

      function getAccessToken() {
        return getCookie('rag_token');
      }

      if (!getAccessToken()) {
        window.location.assign('/frontend/login');
      }

      async function fetchWithAuth(url, options = {}) {
        const token = getAccessToken();
        const headers = new Headers(options.headers || {});
        if (!(options.body instanceof FormData) && options.body && !headers.has('Content-Type')) {
          headers.set('Content-Type', 'application/json');
        }
        if (!headers.has('Accept')) {
          headers.set('Accept', 'application/json');
        }
        if (token) {
          headers.set('Authorization', `Bearer ${token}`);
        }
        return fetch(url, {
          ...options,
          headers,
          credentials: 'same-origin',
        });
      }

      async function fetchJsonWithAuth(url, options = {}) {
        const response = await fetchWithAuth(url, options);
        const contentType = response.headers.get('content-type') || '';
        const isJson = contentType.includes('application/json');
        const payload = isJson ? await response.json().catch(() => null) : await response.text();

        if (response.status === 401) {
          window.location.assign('/frontend/login');
          throw new Error('Authentication required');
        }

        if (!response.ok) {
          const detail =
            (payload && typeof payload === 'object' ? payload.detail || payload.message : null) ||
            (typeof payload === 'string' ? payload : '') ||
            response.statusText;
          throw new Error(detail || `Request failed with status ${response.status}`);
        }

        return payload ?? {};
      }

      function formatTimestamp(value) {
        if (!value) {
          return '';
        }
        const date = new Date(value);
        if (Number.isNaN(date.getTime())) {
          return '';
        }
        return date.toLocaleString(undefined, {
          year: 'numeric',
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });
      }

      function applyStage(stage, message) {
        if (!streamStatus) {
          return;
        }
        const text = message || stageMessages[stage] || '';
        if (text) {
          streamStatus.textContent = text;
        }
        if (stage === 'error') {
          streamStatus.classList.add('status-pill--error');
        } else if (stage !== 'streaming') {
          streamStatus.classList.remove('status-pill--error');
        }
      }

      function setStreamingState(state) {
        streamingState = state;
        if (!streamStatus) {
          return;
        }
        streamStatus.classList.toggle('status-pill--streaming', state === 'streaming');
        if (state !== 'error') {
          streamStatus.classList.remove('status-pill--error');
        }
        stopStreamButton.disabled = state !== 'streaming';
        sendButton.disabled = state === 'streaming';
        chatInput.disabled = state === 'streaming';
        if (state === 'idle' && !streamStatus.textContent) {
          streamStatus.textContent = stageMessages.idle;
        }
      }

      function renderEmptyState() {
        chatWindow.innerHTML = '';
        appendMessage(
          'system',
          'Select an existing conversation or start a new one to begin streaming responses. Messages will appear here.',
        );
      }
      function setSidebarToggleState(isOpen) {
        if (sidebarToggle) {
          sidebarToggle.setAttribute('aria-pressed', String(isOpen));
        }
        if (sidebarToggleIcon) {
          sidebarToggleIcon.innerHTML = isOpen
            ? '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="24" height="24" fill="#eeeeef"><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg>'
            : '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="24" height="24" fill="#eeeeef"><path d="M120-240v-80h720v80H120Zm0-200v-80h720v80H120Zm0-200v-80h720v80H120Z"/></svg>';
        }
      }

      function renderConversationList(conversations) {
        if (!conversationList) {
          return;
        }
        conversationList.innerHTML = '';
        if (!Array.isArray(conversations) || conversations.length === 0) {
          const empty = document.createElement('li');
          empty.className = 'conversation-list__empty';
          empty.textContent = 'No conversations yet. Create your first one to begin.';
          conversationList.appendChild(empty);
          return;
        }
        conversations.forEach((conversation) => {
          const item = document.createElement('li');
          item.className = 'conversation-list__item';
          const button = document.createElement('button');
          button.className = 'conversation-list__button';
          button.type = 'button';
          button.dataset.id = conversation.id;
          button.dataset.title = conversation.title || '';
          if (conversation.id === activeConversationId) {
            button.classList.add('conversation-list__button--active');
          }
          const title = document.createElement('span');
          title.className = 'conversation-list__title';
          title.textContent = conversation.title || 'New session';
          const meta = document.createElement('span');
          meta.className = 'conversation-list__meta';
          meta.textContent = formatTimestamp(conversation.updated_at);
          button.append(title, meta);
          item.appendChild(button);
          conversationList.appendChild(item);
        });
      }

      async function loadConversations() {
        try {
          const sessions = await fetchJsonWithAuth('/chat/sessions');
          renderConversationList(Array.isArray(sessions) ? sessions : []);
        } catch (error) {
          console.error('Failed to load conversations', error);
          applyStage('error', 'Unable to load conversations');
        }
      }

      function appendMessage(type, text, createdAt) {
        const message = document.createElement('div');
        message.className = `message message--${type}`;
        const author = document.createElement('span');
        author.className = 'message__author';
        author.textContent = type === 'user' ? 'You' : type === 'assistant' ? 'Assistant' : 'System';
        const body = document.createElement('div');
        body.className = 'message__content';
        if (type === 'assistant') {
          body.dataset.raw = typeof text === 'string' ? text : '';
          renderMarkdown(body, body.dataset.raw);
        } else {
          body.textContent = text;
        }
        message.append(author, body);

        if (createdAt) {
          const formatted = formatTimestamp(createdAt);
          if (formatted) {
            message.dataset.timestamp = createdAt;
            body.title = formatted;
          }
        }

        let contextDetails = null;
        let contextList = null;
        let citationsList = null;
        if (type === 'assistant') {
          const extras = document.createElement('div');
          extras.className = 'message__extras';

          contextDetails = document.createElement('details');
          contextDetails.className = 'message__context';
          contextDetails.hidden = true;
          const summary = document.createElement('summary');
          summary.textContent = 'Retrieval context';
          contextList = document.createElement('ul');
          contextList.className = 'message__context-list';
          contextDetails.append(summary, contextList);

          citationsList = document.createElement('ul');
          citationsList.className = 'message__citations';
          citationsList.hidden = true;

          extras.append(contextDetails, citationsList);
          message.append(extras);
        }

        chatWindow.appendChild(message);
        chatWindow.scrollTop = chatWindow.scrollHeight;
        message.dataset.hasTokens = '1';
        return { element: message, author, content: body, contextDetails, contextList, citationsList };
      }

      function renderMessages(messages) {
        chatWindow.innerHTML = '';
        if (!Array.isArray(messages) || messages.length === 0) {
          renderEmptyState();
          return;
        }
        messages.forEach((message) => {
          const type =
            message.role === 'assistant' ? 'assistant' : message.role === 'user' ? 'user' : 'system';
          appendMessage(type, message.content, message.created_at);
        });
      }

      async function loadMessages(conversationId) {
        if (!conversationId) {
          renderEmptyState();
          return;
        }
        try {
          const messages = await fetchJsonWithAuth(`/chat/${conversationId}/messages`);
          renderMessages(Array.isArray(messages) ? messages : []);
        } catch (error) {
          console.error('Failed to load messages', error);
          applyStage('error', 'Unable to load messages');
        }
      }

      async function selectConversation(conversationId) {
        if (!conversationId) {
          return;
        }
        activeConversationId = conversationId;
        Array.from(conversationList.querySelectorAll('.conversation-list__button')).forEach((button) => {
          button.classList.toggle('conversation-list__button--active', button.dataset.id === conversationId);
        });
        await loadMessages(conversationId);
        closeSidebar();
      }

      async function createConversation(initialTitle) {
        try {
          const payload = initialTitle ? { title: initialTitle } : { title: null };
          const session = await fetchJsonWithAuth('/chat/sessions', {
            method: 'POST',
            body: JSON.stringify(payload),
          });
          if (session?.id) {
            activeConversationId = session.id;
            await loadConversations();
            renderEmptyState();
            return session.id;
          }
        } catch (error) {
          console.error('Failed to create conversation', error);
          applyStage('error', error.message || 'Failed to create conversation');
        }
        return null;
      }

      function renderContext(chunks, assistant, contextMap) {
        if (!assistant.contextDetails || !assistant.contextList) {
          return;
        }
        contextMap.clear();
        assistant.contextList.innerHTML = '';
        if (!chunks.length) {
          assistant.contextDetails.hidden = true;
          return;
        }
        chunks.forEach((chunk, index) => {
          const chunkId = chunk.chunk_id || `ctx-${index + 1}`;
          contextMap.set(chunkId, { ...chunk, index: index + 1 });
          const item = document.createElement('li');
          const header = document.createElement('div');
          header.className = 'context__header';
          const badge = document.createElement('span');
          badge.className = 'context__label';
          badge.textContent = chunk.label || `[${index + 1}]`;
          const title = document.createElement('span');
          title.className = 'context__title';
          title.textContent =
            chunk.document_title || chunk.metadata?.title || chunk.document_metadata?.title || 'Retrieved snippet';
          header.append(badge, title);

          const snippet = document.createElement('p');
          snippet.className = 'context__snippet';
          snippet.textContent = chunk.snippet || '';

          item.append(header, snippet);
          assistant.contextList.appendChild(item);
        });
        const summary = assistant.contextDetails.querySelector('summary');
        if (summary) {
          summary.textContent = `Retrieval context (${chunks.length})`;
        }
        assistant.contextDetails.hidden = false;
      }

      function renderCitations(citations, assistant, contextMap) {
        if (!assistant.citationsList) {
          return;
        }
        assistant.citationsList.innerHTML = '';
        if (!citations.length) {
          assistant.citationsList.hidden = true;
          return;
        }
        citations.forEach((citation) => {
          const match = contextMap.get(citation.chunk_id) || {};
          const item = document.createElement('li');
          const label = document.createElement('span');
          label.className = 'citation__label';
          label.textContent = citation.label || match.label || '';
          const title = document.createElement('span');
          title.className = 'citation__title';
          title.textContent =
            citation.document_title ||
            match.document_title ||
            match.metadata?.title ||
            match.document_metadata?.title ||
            'Source';
          item.append(label, title);

          const extra = [];
          if (citation.page) {
            extra.push(`p. ${citation.page}`);
          }
          const source =
            citation.source ||
            match.metadata?.source ||
            match.document_metadata?.source ||
            match.document_metadata?.source_path;
          if (source) {
            extra.push(source);
          }
          if (extra.length) {
            const meta = document.createElement('span');
            meta.className = 'citation__meta';
            meta.textContent = extra.join(' • ');
            item.appendChild(meta);
          }
          assistant.citationsList.appendChild(item);
        });
        assistant.citationsList.hidden = false;
      }

      function handleStreamEvent(event, assistant, contextMap) {
        if (!event || typeof event !== 'object') {
          return;
        }
        if (window?.console?.debug) {
          console.debug('chat:stream-event', event);
        }
        switch (event.type) {
          case 'status':
            applyStage(event.stage || 'streaming', event.message);
            break;
          case 'context':
            renderContext(Array.isArray(event.chunks) ? event.chunks : [], assistant, contextMap);
            break;
          case 'token':
            if (!event.text) {
              break;
            }
            if (assistant.element.dataset.hasTokens !== '1') {
              assistant.element.dataset.hasTokens = '1';
              assistant.element.classList.remove('message--pending');
            }
            const raw = (assistant.content.dataset.raw || '') + event.text;
            assistant.content.dataset.raw = raw;
            renderMarkdown(assistant.content, raw);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            break;
          case 'citations':
            renderCitations(Array.isArray(event.citations) ? event.citations : [], assistant, contextMap);
            break;
          case 'error':
            streamingState = 'error';
            setStreamingState('idle');
            applyStage('error', event.message || stageMessages.error);
            assistant.element.classList.remove('message--pending');
            assistant.element.dataset.hasTokens = '1';
            {
              const errorRaw = `${assistant.content.dataset.raw || ''}\n\n⚠️ ${
                event.message || 'Streaming error'
              }`.trim();
              assistant.content.dataset.raw = errorRaw;
              renderMarkdown(assistant.content, errorRaw);
            }
            break;
          case 'done':
            applyStage('complete', event.message || stageMessages.complete);
            setStreamingState('idle');
            if (
              assistant.element.dataset.hasTokens !== '1' &&
              !(assistant.content.dataset.raw || '').trim()
            ) {
              assistant.element.classList.remove('message--pending');
              const fallbackRaw = 'No response generated.';
              assistant.content.dataset.raw = fallbackRaw;
              renderMarkdown(assistant.content, fallbackRaw);
              assistant.element.dataset.hasTokens = '1';
            }
            break;
          default:
            break;
        }
      }

      function processBuffer(buffer, assistant, contextMap, flush = false) {
        let working = buffer;
        let newline = working.indexOf('\n');
        while (newline >= 0) {
          const line = working.slice(0, newline).trim();
          working = working.slice(newline + 1);
          if (line) {
            try {
              const event = JSON.parse(line);
              handleStreamEvent(event, assistant, contextMap);
            } catch (error) {
              console.warn('Failed to parse stream event', line, error);
            }
          }
          newline = working.indexOf('\n');
        }
        if (flush && working.trim()) {
          try {
            const event = JSON.parse(working.trim());
            handleStreamEvent(event, assistant, contextMap);
          } catch (error) {
            console.warn('Failed to parse trailing stream event', working, error);
          }
          return '';
        }
        return working;
      }

      async function streamResponse(conversationId, query, assistant) {
        abortController = new AbortController();
        setStreamingState('streaming');
        applyStage('streaming', stageMessages.retrieving);
        const contextMap = new Map();
        try {
          const response = await fetchWithAuth(`/chat/${conversationId}/messages`, {
            method: 'POST',
            body: JSON.stringify({ query, mode: null }),
            signal: abortController.signal,
          });
          if (response.status === 401) {
            window.location.assign('/frontend/login');
            return;
          }
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText || `HTTP ${response.status}`);
          }
          if (!response.body) {
            const text = await response.text();
            text.split('\n')
              .map((line) => line.trim())
              .filter(Boolean)
              .forEach((line) => {
                try {
                  const event = JSON.parse(line);
                  handleStreamEvent(event, assistant, contextMap);
                } catch (error) {
                  console.warn('Failed to parse buffered event', line, error);
                }
              });
            return;
          }
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            buffer += decoder.decode(value, { stream: true });
            buffer = processBuffer(buffer, assistant, contextMap);
          }
          buffer += decoder.decode();
          processBuffer(buffer, assistant, contextMap, true);
        } catch (error) {
          if (error.name === 'AbortError') {
            applyStage('idle', 'Streaming cancelled.');
          } else {
            console.error('Streaming error', error);
            applyStage('error', error.message || stageMessages.error);
          }
        } finally {
          abortController = null;
          lastAssistantMessage = null;
          if (streamingState !== 'error') {
            setStreamingState('idle');
          }
          streamingState = 'idle';
          await loadConversations();
        }
      }

      function abortStreaming(userInitiated = false) {
        if (abortController) {
          abortController.abort();
          abortController = null;
        }
        setStreamingState('idle');
        if (userInitiated) {
          applyStage('idle', 'Streaming stopped.');
      if (lastAssistantMessage?.content) {
        const stoppedRaw = `${lastAssistantMessage.content.dataset.raw || ''} (stream stopped)`;
        lastAssistantMessage.content.dataset.raw = stoppedRaw;
        renderMarkdown(lastAssistantMessage.content, stoppedRaw);
      }
        }
      }

      chatForm?.addEventListener('submit', async (event) => {
        event.preventDefault();
        const value = chatInput.value.trim();
        if (!value) {
          return;
        }
        let conversationId = activeConversationId;
        if (!conversationId) {
          conversationId = await createConversation(value.slice(0, 60));
        }
        if (!conversationId) {
          return;
        }
        appendMessage('user', value, new Date().toISOString());
        chatInput.value = '';
        const assistant = appendMessage('assistant', '');
        assistant.content.dataset.raw = '';
        renderMarkdown(assistant.content, '');
        assistant.element.dataset.hasTokens = '0';
        assistant.element.classList.add('message--pending');
        lastAssistantMessage = assistant;
        await streamResponse(conversationId, value, assistant);
      });

      stopStreamButton?.addEventListener('click', () => {
        abortStreaming(true);
      });

      conversationList?.addEventListener('click', async (event) => {
        const button = event.target.closest('button[data-id]');
        if (!button) {
          return;
        }
        await selectConversation(button.dataset.id);
      });

      newConversationButton?.addEventListener('click', async () => {
        const conversationId = await createConversation(null);
        if (conversationId) {
          await selectConversation(conversationId);
        }
      });

      renderEmptyState();
      setStreamingState('idle');
      applyStage('idle', stageMessages.idle);
      void loadConversations();
    </script>
  </body>
</html>
