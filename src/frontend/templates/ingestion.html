<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>RAG Platform – Ingestion</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="{{ url_for('frontend_static', path='ingestion.css') }}"
    />
  </head>
  <body data-admin="{{ 'true' if is_admin else 'false' }}">
    <header class="workspace-header" id="ingestion-header">
      <div class="workspace-header__lead">
        <h1>Ingestion Workflow</h1>
        <p>Scan PDFs with Docling, chunk intelligently, and feed collections ready for retrieval.</p>
      </div>
      <div class="workspace-header__meta">
        <span class="workspace-pill">Docling pipeline</span>
        <span class="workspace-pill">Chunking with citations</span>
      </div>
    </header>

    <div class="ingestion-layout" id="ingestion-layout">
      <section class="ingestion-panel ingestion-panel--input">
        <header class="panel-heading">
          <div>
            <h2>Document Intake</h2>
            <p>Drop PDFs or browse files. Each document will be parsed by Docling prior to chunking.</p>
          </div>
          <div class="panel-heading__actions">
            <input class="visually-hidden" id="file-input" type="file" accept="application/pdf" multiple />
            <button class="button button--ghost" id="file-browse" type="button">Browse files</button>
            <button class="button button--ghost" id="file-clear" type="button" disabled>Clear</button>
          </div>
        </header>

        <div class="dropzone" id="dropzone" role="button" tabindex="0">
          <span class="dropzone__icon"></span>
          <p class="dropzone__text">
            Drag & drop PDF documents here <br />or click to add them to the queue.
          </p>
          <p class="dropzone__hint">Docling will classify layout, extract text, tables, and figures.</p>
        </div>

        <ul class="file-list" id="file-list" aria-live="polite"></ul>

        <form class="config" id="ingestion-config">
          <h3>Chunking strategy</h3>
          <div class="config__grid">
            <label class="config__field">
              <span>Chunk size (tokens)</span>
              <input
                type="number"
                name="chunk_size"
                value="{{ chunk_defaults.size }}"
                min="100"
                max="2000"
                step="50"
                required
              />
            </label>
            <label class="config__field">
              <span>Chunk overlap (tokens)</span>
              <input
                type="number"
                name="chunk_overlap"
                value="{{ chunk_defaults.overlap }}"
                min="0"
                max="500"
                step="10"
                required
              />
            </label>
            <label class="config__field">
              <span>Collection</span>
              <select name="collection" id="collection-select" required>
                {% for collection in collections %}
                  <option
                    value="{{ collection.name }}"
                    data-default-size="{{ collection.default_chunk_size }}"
                    data-default-overlap="{{ collection.default_chunk_overlap }}"
                  >
                    {{ collection.name }} • {{ collection.document_count }} docs
                  </option>
                {% endfor %}
              </select>
            </label>
            <label class="config__toggle">
              <input type="checkbox" name="include_tables" checked />
              <span>Preserve tables & figures (Docling structured output)</span>
            </label>
            <label class="config__toggle">
              <input type="checkbox" name="generate_citations" checked />
              <span>Generate citation metadata for each chunk</span>
            </label>
          </div>
        </form>
      </section>

      <section class="ingestion-panel ingestion-panel--workflow" id="workflow-panel">
        <header class="panel-heading">
          <div>
            <h2>Pipeline Orchestration</h2>
            <p>Kick off the ingestion workflow, monitor Docling parsing, chunking and citation extraction.</p>
          </div>
          <div class="panel-heading__actions">
            <button class="button button--ghost" id="reset-workflow" type="button">Reset</button>
            <button class="button button--primary" id="run-workflow" type="button" disabled>
              <span class="icon icon--spark"></span>
              Run ingestion
            </button>
          </div>
        </header>

        <ol class="pipeline" id="pipeline">
          <li class="pipeline__step" data-step="docling">
            <div class="pipeline__status">Pending</div>
            <div class="pipeline__content">
              <h3>Docling parse</h3>
              <p>Convert PDFs to Docling JSON, classify layout blocks, detect tables, assign reading order.</p>
              <pre class="pipeline__code" aria-hidden="true">docling.parse(document)</pre>
            </div>
          </li>
          <li class="pipeline__step" data-step="chunking">
            <div class="pipeline__status">Pending</div>
            <div class="pipeline__content">
              <h3>Chunk assembly</h3>
              <p>Segment semantic chunks with sliding windows using configured size & overlap.</p>
              <pre class="pipeline__code">docling.make_chunks(size, overlap)</pre>
            </div>
          </li>
          <li class="pipeline__step" data-step="embeddings">
            <div class="pipeline__status">Pending</div>
            <div class="pipeline__content">
              <h3>Embedding & indexing</h3>
              <p>Embed each chunk with the active model, stage payloads, upsert into vector store collection.</p>
              <pre class="pipeline__code">vector_index.upsert(chunks)</pre>
            </div>
          </li>
          <li class="pipeline__step" data-step="citations">
            <div class="pipeline__status">Pending</div>
            <div class="pipeline__content">
              <h3>Citation enrichment</h3>
              <p>Link chunk spans back to document coordinates and build citation graph for downstream usage.</p>
              <pre class="pipeline__code">citation_engine.create_links(chunks)</pre>
            </div>
          </li>
        </ol>

        <section class="workflow-preview" id="workflow-preview">
          <header>
            <h3>Preview</h3>
            <p>Docling artefacts, chunk statistics and citation stubs appear here once the workflow runs.</p>
          </header>
          <div class="preview-grid">
            <article class="preview-card" id="preview-docling">
              <h4>Docling extract</h4>
              <pre>{"status": "waiting for run"}</pre>
            </article>
            <article class="preview-card" id="preview-chunks">
              <h4>Chunk summary</h4>
              <pre>{"status": "waiting for run"}</pre>
            </article>
            <article class="preview-card" id="preview-citations">
              <h4>Citations</h4>
              <pre>{"status": "waiting for run"}</pre>
            </article>
          </div>
        </section>

        <section class="job-history">
          <header>
            <h3>Recent jobs</h3>
            <button class="link-button" id="refresh-jobs" type="button">Refresh</button>
          </header>
          <table>
            <thead>
              <tr>
                <th scope="col">Job ID</th>
                <th scope="col">Source</th>
                <th scope="col">Collection</th>
                <th scope="col">Status</th>
                <th scope="col">Updated</th>
              </tr>
            </thead>
            <tbody id="job-table-body">
              {% for job in recent_jobs %}
                <tr>
                  <td>{{ job.id }}</td>
                  <td>{{ job.source }}</td>
                  <td>{{ job.collection }}</td>
                  <td><span class="status-pill status-pill--{{ job.status }}">{{ job.status }}</span></td>
                  <td>{{ job.updated_at }}</td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </section>
      </section>
    </div>

    <script>
      const fileInput = document.getElementById('file-input');
      const fileBrowse = document.getElementById('file-browse');
      const fileClear = document.getElementById('file-clear');
      const dropzone = document.getElementById('dropzone');
      const fileList = document.getElementById('file-list');
      const runWorkflow = document.getElementById('run-workflow');
      const resetWorkflow = document.getElementById('reset-workflow');
      const configForm = document.getElementById('ingestion-config');
      const pipelineElement = document.getElementById('pipeline');
      const previewDocling = document.getElementById('preview-docling').querySelector('pre');
      const previewChunks = document.getElementById('preview-chunks').querySelector('pre');
      const previewCitations = document.getElementById('preview-citations').querySelector('pre');
      const jobTableBody = document.getElementById('job-table-body');
      const ingestionHeader = document.getElementById('ingestion-header');
      const workflowPanel = document.getElementById('workflow-panel');

      let queue = [];
      const cookieValue = document.cookie.split('; ').find((row) => row.startsWith('rag_admin='));
      const adminFlag = cookieValue ? cookieValue.split('=')[1] === '1' : document.body.dataset.admin === 'true';

      if (!adminFlag) {
        workflowPanel.hidden = true;
        ingestionHeader.querySelector('.workspace-header__lead p').textContent =
          'Upload PDFs to request ingestion. Administrators can run Docling workflows or review jobs in the console.';
      }
      let pipelineTimer = null;

      document.getElementById('collection-select')?.addEventListener('change', (event) => {
        const select = event.target;
        if (!(select instanceof HTMLSelectElement)) {
          return;
        }
        const option = select.selectedOptions[0];
        if (!option) {
          return;
        }
        const size = Number(option.dataset.defaultSize);
        const overlap = Number(option.dataset.defaultOverlap);
        if (size) {
          configForm.elements.namedItem('chunk_size').value = String(size);
        }
        if (overlap >= 0) {
          configForm.elements.namedItem('chunk_overlap').value = String(overlap);
        }
      });

      function updateQueueView() {
        fileList.innerHTML = '';
        if (!queue.length) {
          fileList.innerHTML = '<li class="file-list__empty">No documents queued yet.</li>';
          runWorkflow.disabled = true;
          fileClear.disabled = true;
          return;
        }
        queue.forEach((file, index) => {
          const item = document.createElement('li');
          item.className = 'file-list__item';
          item.innerHTML = `
            <span>
              <strong>${file.name}</strong>
              <small>${(file.size / 1024 / 1024).toFixed(2)} MB</small>
            </span>
            <button class="chip" data-index="${index}" type="button">Remove</button>
          `;
          fileList.appendChild(item);
        });
        runWorkflow.disabled = false;
        fileClear.disabled = false;
      }

      function addFiles(files) {
        const pdfs = Array.from(files).filter((file) => file.type === 'application/pdf');
        queue = queue.concat(pdfs);
        updateQueueView();
      }

      fileBrowse.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', (event) => addFiles(event.target.files));

      fileClear.addEventListener('click', () => {
        queue = [];
        updateQueueView();
      });

      fileList.addEventListener('click', (event) => {
        const button = event.target.closest('button[data-index]');
        if (!button) {
          return;
        }
        const index = Number(button.dataset.index);
        queue.splice(index, 1);
        updateQueueView();
      });

      function highlightDropzone(active) {
        dropzone.classList.toggle('dropzone--active', active);
      }

      dropzone.addEventListener('dragover', (event) => {
        event.preventDefault();
        highlightDropzone(true);
      });

      dropzone.addEventListener('dragleave', () => highlightDropzone(false));

      dropzone.addEventListener('drop', (event) => {
        event.preventDefault();
        highlightDropzone(false);
        addFiles(event.dataTransfer.files);
      });

      dropzone.addEventListener('click', () => fileInput.click());
      dropzone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      function setStepStatus(step, status, detail) {
        const element = pipelineElement.querySelector(`[data-step="${step}"]`);
        if (!element) return;
        element.classList.remove('pipeline__step--pending', 'pipeline__step--running', 'pipeline__step--done', 'pipeline__step--error');
        element.classList.add(`pipeline__step--${status}`);
        element.querySelector('.pipeline__status').textContent = status.charAt(0).toUpperCase() + status.slice(1);
        if (detail) {
          element.querySelector('.pipeline__content p').textContent = detail;
        }
      }

      function resetPipeline() {
        ['docling', 'chunking', 'embeddings', 'citations'].forEach((step) => setStepStatus(step, 'pending'));
        previewDocling.textContent = '{"status": "waiting for run"}';
        previewChunks.textContent = '{"status": "waiting for run"}';
        previewCitations.textContent = '{"status": "waiting for run"}';
        if (pipelineTimer) {
          window.clearTimeout(pipelineTimer);
          pipelineTimer = null;
        }
      }

      resetWorkflow.addEventListener('click', () => {
        queue = [];
        updateQueueView();
        resetPipeline();
      });

      const stepMap = {
        docling_parse: 'docling',
        chunk_assembly: 'chunking',
        embedding_indexing: 'embeddings',
        citation_enrichment: 'citations',
      };

      function pipelineStatus(status) {
        switch (status) {
          case 'running':
            return 'running';
          case 'success':
            return 'done';
          case 'failed':
            return 'error';
          default:
            return 'pending';
        }
      }

      function describeEvent(event) {
        if (!event?.detail) return undefined;
        if (event.step === 'docling_parse' && event.detail.documents !== undefined) {
          return `Parsed ${event.detail.documents} document(s)`;
        }
        if (event.step === 'chunk_assembly' && event.detail.chunks !== undefined) {
          return `Chunks: ${event.detail.chunks}`;
        }
        if (event.step === 'embedding_indexing' && event.detail.chunks_embedded !== undefined) {
          return `Embedded ${event.detail.chunks_embedded} chunk(s)`;
        }
        if (event.step === 'citation_enrichment' && Array.isArray(event.detail.citations)) {
          return `Citations linked: ${event.detail.citations.length}`;
        }
        return undefined;
      }

      function updatePreviews(events, config) {
        events.forEach((event) => {
          if (!event.detail) return;
          if (event.step === 'docling_parse') {
            previewDocling.textContent = JSON.stringify(event.detail, null, 2);
          }
          if (event.step === 'chunk_assembly') {
            const detail = { chunk_size: config.chunk_size, chunk_overlap: config.chunk_overlap, ...event.detail };
            previewChunks.textContent = JSON.stringify(detail, null, 2);
          }
          if (event.step === 'embedding_indexing') {
            const current = previewChunks.textContent ? JSON.parse(previewChunks.textContent) : {};
            previewChunks.textContent = JSON.stringify({ ...current, ...event.detail }, null, 2);
          }
          if (event.step === 'citation_enrichment') {
            previewCitations.textContent = JSON.stringify(event.detail, null, 2);
          }
        });
      }

      function applyJobState(job, config) {
        if (!job?.events) return;
        updatePreviews(job.events, config);
        job.events.forEach((event) => {
          const stepKey = stepMap[event.step];
          if (!stepKey) return;
          setStepStatus(stepKey, pipelineStatus(event.status), describeEvent(event));
        });
        if (job.status === 'failed') {
          setStepStatus('citations', 'error', job.error_message || 'Ingestion failed');
        }
      }

      function appendJobRow(job) {
        let row = jobTableBody.querySelector(`tr[data-job-id="${job.id}"]`);
        if (!row) {
          row = document.createElement('tr');
          row.dataset.jobId = job.id;
          row.innerHTML = `
            <td class="job-id"></td>
            <td class="job-source"></td>
            <td class="job-collection"></td>
            <td class="job-status"></td>
            <td class="job-updated"></td>
          `;
          jobTableBody.prepend(row);
        }
        row.querySelector('.job-id').textContent = job.id;
        row.querySelector('.job-source').textContent = job.source;
        row.querySelector('.job-collection').textContent = job.collection;
        row.querySelector('.job-status').innerHTML = `<span class="status-pill status-pill--${job.status}">${job.status}</span>`;
        row.querySelector('.job-updated').textContent = job.updated_at;
      }

      async function submitJobs(config) {
        const body = new FormData();
        queue.forEach((file) => body.append('files', file));
        body.append('collection', config.collection);
        body.append('chunk_size', String(config.chunk_size));
        body.append('chunk_overlap', String(config.chunk_overlap));
        body.append(
          'metadata',
          JSON.stringify({ include_tables: config.include_tables, generate_citations: config.generate_citations })
        );
        const response = await fetch('/ingestion/jobs/upload', { method: 'POST', body });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(text || 'Ingestion request failed');
        }
        return response.json();
      }

      async function pollJob(jobId, config) {
        let complete = false;
        while (!complete) {
          const response = await fetch(`/ingestion/jobs/${jobId}`, { headers: { Accept: 'application/json' } });
          if (!response.ok) {
            throw new Error('Failed to fetch job status');
          }
          const job = await response.json();
          applyJobState(job, config);
          appendJobRow({
            id: job.id,
            source: job.source,
            collection: job.collection_name,
            status: job.status,
            updated_at: new Date(job.updated_at).toLocaleString(),
          });
          complete = job.status === 'success' || job.status === 'failed';
          if (!complete) {
            // eslint-disable-next-line no-await-in-loop
            await new Promise((resolve) => setTimeout(resolve, 2000));
          }
        }
      }

      runWorkflow.addEventListener('click', async () => {
        const formData = new FormData(configForm);
        const config = {
          chunk_size: Number(formData.get('chunk_size')),
          chunk_overlap: Number(formData.get('chunk_overlap')),
          collection: String(formData.get('collection')),
          include_tables: formData.get('include_tables') === 'on',
          generate_citations: formData.get('generate_citations') === 'on',
        };

        resetPipeline();
        previewChunks.textContent = JSON.stringify({ chunk_size: config.chunk_size, chunk_overlap: config.chunk_overlap }, null, 2);

        try {
          runWorkflow.disabled = true;
          const jobs = await submitJobs(config);
          queue = [];
          updateQueueView();
          await Promise.all(jobs.map((job) => pollJob(job.id, config)));
        } catch (error) {
          console.error(error);
          setStepStatus('docling', 'error', 'Upload failed');
        } finally {
          runWorkflow.disabled = false;
        }
      });

      document.getElementById('refresh-jobs')?.addEventListener('click', async () => {
        try {
          const [collectionsResponse, jobsResponse] = await Promise.all([
            fetch('/ingestion/collections', { headers: { Accept: 'application/json' } }),
            fetch('/ingestion/jobs', { headers: { Accept: 'application/json' } }),
          ]);
          if (!collectionsResponse.ok) {
            throw new Error('Failed to refresh collections');
          }
          if (!jobsResponse.ok) {
            throw new Error('Failed to fetch jobs');
          }
          const collectionsData = await collectionsResponse.json();
          const select = document.getElementById('collection-select');
          select.innerHTML = '';
          collectionsData.forEach((item) => {
            const option = document.createElement('option');
            option.value = item.name;
            option.dataset.defaultSize = item.default_chunk_size;
            option.dataset.defaultOverlap = item.default_chunk_overlap;
            option.textContent = `${item.name} • ${item.document_count} docs`;
            select.appendChild(option);
          });

          const jobsData = await jobsResponse.json();
          jobTableBody.innerHTML = '';
          jobsData.forEach((job) => {
            appendJobRow({
              id: job.id,
              source: job.source,
              collection: job.collection_name,
              status: job.status,
              updated_at: new Date(job.updated_at).toLocaleString(),
            });
          });
        } catch (error) {
          console.error(error);
        }
      });

      updateQueueView();
    </script>
  </body>
</html>
